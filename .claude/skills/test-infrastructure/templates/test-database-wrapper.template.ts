/**
 * Test Database Wrapper Template
 *
 * Generated by test-infrastructure skill
 *
 * Provides utilities for database test isolation, cleanup, and seed data management.
 * Helps prevent test pollution and ensures consistent test state.
 *
 * Usage:
 * - Use withTestDatabase() for isolated test execution
 * - Use cleanup helpers in afterEach hooks
 * - Use seed data helpers for consistent test fixtures
 */

import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';
import { nanoid } from 'nanoid';

/**
 * Get Supabase client for testing
 * Uses service role key to bypass RLS for test setup/teardown
 */
export function getTestSupabaseClient(): SupabaseClient<Database> {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseKey) {
    throw new Error(
      'Missing Supabase credentials. Set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY in .env.test'
    );
  }

  return createClient<Database>(supabaseUrl, supabaseKey, {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
    },
  });
}

/**
 * Pattern 1: Test database wrapper with automatic cleanup
 *
 * Executes test function with isolated database state
 * Cleans up all test data after execution (even if test fails)
 *
 * Usage:
 * ```typescript
 * it('creates asset', async () => {
 *   await withTestDatabase(async (supabase) => {
 *     const asset = await createAsset(supabase);
 *     expect(asset).toBeDefined();
 *   });
 * });
 * ```
 */
export async function withTestDatabase<T>(
  testFn: (supabase: SupabaseClient<Database>) => Promise<T>,
  options: {
    cleanup?: boolean; // Default: true
    seedData?: boolean; // Default: false
  } = {}
): Promise<T> {
  const { cleanup = true, seedData = false } = options;

  const supabase = getTestSupabaseClient();
  const testId = nanoid(8);

  // Generate unique IDs for this test run
  const tenantId = `ten_test_${testId}`;
  const userId = `usr_test_${testId}`;

  try {
    // Seed data if requested
    if (seedData) {
      await seedTestData(supabase, tenantId, userId);
    }

    // Run test function
    const result = await testFn(supabase);

    return result;
  } finally {
    // Cleanup if enabled
    if (cleanup) {
      await cleanupTestData(supabase, tenantId, userId);
    }
  }
}

/**
 * Pattern 2: Seed test data
 *
 * Creates standard test fixtures: tenant, user, and links them
 * Returns IDs for use in tests
 */
export async function seedTestData(
  supabase: SupabaseClient<Database>,
  tenantId: string,
  userId: string
): Promise<{
  tenantId: string;
  userId: string;
}> {
  // 1. Create tenant hub
  await supabase
    .from('dv.hub_tenant')
    .insert({
      tenant_id: tenantId,
      load_timestamp: new Date().toISOString(),
    });

  // 2. Create tenant profile
  await supabase
    .from('dv.sat_tenant_profile')
    .insert({
      tenant_id: tenantId,
      name: `Test Tenant ${tenantId}`,
      load_timestamp: new Date().toISOString(),
    });

  // 3. Create user hub
  await supabase
    .from('dv.hub_user')
    .insert({
      user_id: userId,
      load_timestamp: new Date().toISOString(),
    });

  // 4. Create user profile
  await supabase
    .from('dv.sat_user_profile')
    .insert({
      user_id: userId,
      email: `test-${userId}@example.com`,
      load_timestamp: new Date().toISOString(),
    });

  // 5. Link user to tenant
  await supabase
    .from('dv.link_user_tenant')
    .insert({
      user_id: userId,
      tenant_id: tenantId,
      load_timestamp: new Date().toISOString(),
    });

  return { tenantId, userId };
}

/**
 * Pattern 3: Cleanup test data
 *
 * Deletes all test data in reverse order of foreign key dependencies
 * Critical: Delete children before parents to avoid FK violations
 */
export async function cleanupTestData(
  supabase: SupabaseClient<Database>,
  tenantId: string,
  userId: string
): Promise<void> {
  try {
    // Delete in reverse order of foreign keys (children first, parents last)

    // 1. Delete entity satellites (if any)
    // Add your entity-specific cleanup here:
    // await supabase.from('dv.sat_asset_metadata').delete().eq('tenant_id', tenantId);
    // await supabase.from('dv.sat_workflow_metadata').delete().eq('tenant_id', tenantId);

    // 2. Delete links
    await supabase
      .from('dv.link_user_tenant')
      .delete()
      .eq('tenant_id', tenantId);

    await supabase
      .from('dv.link_user_tenant')
      .delete()
      .eq('user_id', userId);

    // 3. Delete satellites
    await supabase
      .from('dv.sat_user_profile')
      .delete()
      .eq('user_id', userId);

    await supabase
      .from('dv.sat_tenant_profile')
      .delete()
      .eq('tenant_id', tenantId);

    // 4. Delete hubs (last)
    await supabase
      .from('dv.hub_user')
      .delete()
      .eq('user_id', userId);

    await supabase
      .from('dv.hub_tenant')
      .delete()
      .eq('tenant_id', tenantId);

  } catch (error) {
    // eslint-disable-next-line no-console
    console.error('Error during test cleanup:', error);
    // Don't throw - cleanup failures shouldn't break tests
  }
}

/**
 * Pattern 4: Clean up specific entity type
 *
 * Deletes all test data for a specific entity type
 * Useful when you only need to clean up part of test data
 */
export async function cleanupEntity(
  supabase: SupabaseClient<Database>,
  tableName: string,
  filterColumn: string,
  filterValue: string
): Promise<void> {
  try {
    const { error } = await supabase
      .from(tableName)
      .delete()
      .eq(filterColumn, filterValue);

    if (error) {
      // eslint-disable-next-line no-console
      console.error(`Error cleaning up ${tableName}:`, error);
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(`Cleanup failed for ${tableName}:`, error);
  }
}

/**
 * Pattern 5: Transaction-based isolation (experimental)
 *
 * WARNING: Not all Supabase operations support explicit transactions
 * Use with caution and test thoroughly
 *
 * @experimental
 */
export async function withTransaction<T>(
  supabase: SupabaseClient<Database>,
  testFn: (supabase: SupabaseClient<Database>) => Promise<T>
): Promise<T> {
  // Start transaction
  await supabase.rpc('begin_transaction');

  try {
    // Run test
    const result = await testFn(supabase);

    // Rollback transaction (don't commit test data)
    await supabase.rpc('rollback_transaction');

    return result;
  } catch (error) {
    // Rollback on error
    await supabase.rpc('rollback_transaction');
    throw error;
  }
}

/**
 * Pattern 6: Generate unique test IDs
 *
 * Creates unique IDs for test entities to avoid conflicts
 * between parallel test runs
 */
export function generateTestIds(prefix: string = 'test'): {
  tenantId: string;
  userId: string;
  assetId: string;
  workflowId: string;
} {
  const id = nanoid(16);

  return {
    tenantId: `ten_${prefix}_${id}`,
    userId: `usr_${prefix}_${id}`,
    assetId: `ast_${prefix}_${id}`,
    workflowId: `wfl_${prefix}_${id}`,
  };
}

/**
 * Pattern 7: Wait for database propagation
 *
 * Useful when testing eventual consistency or async operations
 * Polls database until condition is met or timeout
 */
export async function waitForDatabaseCondition<T>(
  checkFn: () => Promise<T | null>,
  options: {
    timeout?: number; // milliseconds
    interval?: number; // milliseconds
    description?: string;
  } = {}
): Promise<T> {
  const {
    timeout = 5000,
    interval = 100,
    description = 'condition',
  } = options;

  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    const result = await checkFn();

    if (result !== null && result !== undefined) {
      return result;
    }

    await new Promise(resolve => setTimeout(resolve, interval));
  }

  throw new Error(`Timeout waiting for database ${description} (${timeout}ms)`);
}

/**
 * USAGE EXAMPLES:
 *
 * Example 1: Basic test with cleanup
 * ```typescript
 * import { withTestDatabase } from '@/__tests__/helpers/test-database';
 *
 * describe('Asset API', () => {
 *   it('creates asset', async () => {
 *     await withTestDatabase(async (supabase) => {
 *       const { data, error } = await supabase
 *         .from('dv.sat_asset_metadata')
 *         .insert({ ... });
 *
 *       expect(error).toBeNull();
 *       expect(data).toBeDefined();
 *     });
 *     // Cleanup happens automatically
 *   });
 * });
 * ```
 *
 * Example 2: Test with seed data
 * ```typescript
 * it('lists user assets', async () => {
 *   await withTestDatabase(
 *     async (supabase) => {
 *       // Tenant and user already created
 *       const { data } = await supabase
 *         .from('dv.sat_asset_metadata')
 *         .select('*');
 *
 *       expect(data).toEqual([]);
 *     },
 *     { seedData: true }
 *   );
 * });
 * ```
 *
 * Example 3: Manual cleanup in afterEach
 * ```typescript
 * describe('Complex tests', () => {
 *   const testIds = generateTestIds('complex');
 *   let supabase: SupabaseClient;
 *
 *   beforeEach(async () => {
 *     supabase = getTestSupabaseClient();
 *     await seedTestData(supabase, testIds.tenantId, testIds.userId);
 *   });
 *
 *   afterEach(async () => {
 *     await cleanupTestData(supabase, testIds.tenantId, testIds.userId);
 *   });
 *
 *   it('test 1', async () => { ... });
 *   it('test 2', async () => { ... });
 * });
 * ```
 *
 * Example 4: Wait for async operation
 * ```typescript
 * it('processes asset upload', async () => {
 *   await withTestDatabase(async (supabase) => {
 *     // Trigger async upload
 *     await triggerAssetUpload(assetId);
 *
 *     // Wait for processing to complete
 *     const processedAsset = await waitForDatabaseCondition(
 *       async () => {
 *         const { data } = await supabase
 *           .from('dv.sat_asset_metadata')
 *           .select('*')
 *           .eq('id', assetId)
 *           .eq('status', 'processed')
 *           .single();
 *
 *         return data;
 *       },
 *       { timeout: 10000, description: 'asset processing' }
 *     );
 *
 *     expect(processedAsset.status).toBe('processed');
 *   });
 * });
 * ```
 *
 * Example 5: Specific entity cleanup
 * ```typescript
 * afterEach(async () => {
 *   const supabase = getTestSupabaseClient();
 *
 *   // Only clean up assets, leave tenant/user for other tests
 *   await cleanupEntity(
 *     supabase,
 *     'dv.sat_asset_metadata',
 *     'tenant_id',
 *     testIds.tenantId
 *   );
 * });
 * ```
 */

/**
 * CUSTOMIZATION NOTES:
 *
 * 1. Update cleanup order:
 *    - Add your entity tables to cleanupTestData()
 *    - Delete children before parents (foreign key order)
 *    - List in reverse order of creation
 *
 * 2. Extend seed data:
 *    - Add more fixtures to seedTestData()
 *    - Create entity-specific seed functions
 *    - Add parameters for optional seed data
 *
 * 3. Add entity-specific helpers:
 *    - createTestAsset(supabase, tenantId, overrides)
 *    - createTestWorkflow(supabase, userId, overrides)
 *    - deleteTestAssets(supabase, tenantId)
 *
 * 4. Environment setup:
 *    - Ensure .env.test has correct Supabase credentials
 *    - Use local Supabase instance for tests (not production!)
 *    - Set SUPABASE_SERVICE_ROLE_KEY to bypass RLS during setup/teardown
 *
 * 5. Performance optimization:
 *    - Use batch deletes where possible
 *    - Consider using database transactions if supported
 *    - Pool connections for better performance
 *    - Run tests in parallel with unique test IDs
 *
 * TROUBLESHOOTING:
 *
 * Issue: "Foreign key violation during cleanup"
 * Solution: Check deletion order in cleanupTestData(), delete children first
 *
 * Issue: "Test data from previous run still exists"
 * Solution: Ensure cleanup runs in afterEach, use unique test IDs
 *
 * Issue: "Cleanup is slow"
 * Solution: Use batch operations, consider database transactions
 *
 * Issue: "Tests interfere with each other"
 * Solution: Use generateTestIds() to create unique IDs per test
 */
