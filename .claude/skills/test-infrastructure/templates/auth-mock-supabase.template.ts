/**
 * Supabase Auth Mocking Template
 *
 * Generated by test-infrastructure skill
 *
 * This file provides reusable patterns for mocking Supabase authentication
 * in Vitest tests, with support for multi-tenant contexts.
 *
 * Usage:
 * - Import the functions you need into your test files
 * - Customize mock data for your specific test scenarios
 * - Use createMockSupabaseClient() to create type-safe mocks
 */

import { vi } from 'vitest';
import type { SupabaseClient, User, Session } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';

/**
 * Standard mock IDs for testing
 * Use these consistently across tests for predictability
 */
export const MOCK_IDS = {
  TENANT_ID: 'ten_test_01234567890123456789',
  USER_ID: 'usr_test_01234567890123456789',
  ADMIN_USER_ID: 'usr_admin_01234567890123456789',
  SECOND_TENANT_ID: 'ten_test_99999999999999999999',
  SECOND_USER_ID: 'usr_test_99999999999999999999',
} as const;

/**
 * Mock user data matching Supabase User type
 */
export const MOCK_USER: User = {
  id: MOCK_IDS.USER_ID,
  aud: 'authenticated',
  role: 'authenticated',
  email: 'test@example.com',
  email_confirmed_at: new Date().toISOString(),
  phone: null,
  confirmed_at: new Date().toISOString(),
  last_sign_in_at: new Date().toISOString(),
  app_metadata: {
    provider: 'email',
    providers: ['email'],
  },
  user_metadata: {
    tenant_id: MOCK_IDS.TENANT_ID,
  },
  identities: [],
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
};

/**
 * Mock session data matching Supabase Session type
 */
export const MOCK_SESSION: Session = {
  access_token: 'mock-access-token',
  token_type: 'bearer',
  expires_in: 3600,
  expires_at: Math.floor(Date.now() / 1000) + 3600,
  refresh_token: 'mock-refresh-token',
  user: MOCK_USER,
};

/**
 * Pattern 1: Authenticated user with tenant context (MOST COMMON)
 *
 * Use this for testing routes that require:
 * - User authentication
 * - Tenant scoping
 * - Standard user permissions
 */
export function createMockSupabaseClient(
  userId: string = MOCK_IDS.USER_ID,
  tenantId: string = MOCK_IDS.TENANT_ID
): SupabaseClient<Database> {
  const mockUser: User = {
    ...MOCK_USER,
    id: userId,
    user_metadata: { tenant_id: tenantId },
  };

  return {
    auth: {
      getUser: vi.fn().mockResolvedValue({
        data: { user: mockUser },
        error: null,
      }),
      getSession: vi.fn().mockResolvedValue({
        data: {
          session: {
            ...MOCK_SESSION,
            user: mockUser,
          },
        },
        error: null,
      }),
      signOut: vi.fn().mockResolvedValue({
        error: null,
      }),
    },
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    insert: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    delete: vi.fn().mockReturnThis(),
    upsert: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    neq: vi.fn().mockReturnThis(),
    gt: vi.fn().mockReturnThis(),
    gte: vi.fn().mockReturnThis(),
    lt: vi.fn().mockReturnThis(),
    lte: vi.fn().mockReturnThis(),
    like: vi.fn().mockReturnThis(),
    ilike: vi.fn().mockReturnThis(),
    in: vi.fn().mockReturnThis(),
    contains: vi.fn().mockReturnThis(),
    order: vi.fn().mockReturnThis(),
    limit: vi.fn().mockReturnThis(),
    range: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({
      data: null,
      error: null,
    }),
    maybeSingle: vi.fn().mockResolvedValue({
      data: null,
      error: null,
    }),
  } as unknown as SupabaseClient<Database>;
}

/**
 * Pattern 2: Unauthenticated user
 *
 * Use this for testing:
 * - Login/signup flows
 * - Public endpoints
 * - 401 error handling
 */
export function createUnauthenticatedSupabaseClient(): SupabaseClient<Database> {
  return {
    auth: {
      getUser: vi.fn().mockResolvedValue({
        data: { user: null },
        error: { message: 'Not authenticated', status: 401 },
      }),
      getSession: vi.fn().mockResolvedValue({
        data: { session: null },
        error: { message: 'Not authenticated', status: 401 },
      }),
      signInWithPassword: vi.fn().mockResolvedValue({
        data: { user: null, session: null },
        error: { message: 'Invalid credentials', status: 401 },
      }),
    },
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({
      data: null,
      error: { message: 'No rows found' },
    }),
  } as unknown as SupabaseClient<Database>;
}

/**
 * Pattern 3: Admin user
 *
 * Use this for testing:
 * - Admin-only routes
 * - Privileged operations
 * - Cross-tenant access
 */
export function createMockAdminSupabaseClient(): SupabaseClient<Database> {
  const adminUser: User = {
    ...MOCK_USER,
    id: MOCK_IDS.ADMIN_USER_ID,
    email: 'admin@example.com',
    user_metadata: {
      tenant_id: MOCK_IDS.TENANT_ID,
      role: 'admin',
    },
  };

  return {
    auth: {
      getUser: vi.fn().mockResolvedValue({
        data: { user: adminUser },
        error: null,
      }),
      getSession: vi.fn().mockResolvedValue({
        data: {
          session: {
            ...MOCK_SESSION,
            user: adminUser,
          },
        },
        error: null,
      }),
    },
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({
      data: null,
      error: null,
    }),
  } as unknown as SupabaseClient<Database>;
}

/**
 * Pattern 4: User without tenant (onboarding flow)
 *
 * Use this for testing:
 * - Onboarding flows
 * - Tenant creation
 * - First-time user setup
 */
export function createMockSupabaseClientWithoutTenant(
  userId: string = MOCK_IDS.USER_ID
): SupabaseClient<Database> {
  const userWithoutTenant: User = {
    ...MOCK_USER,
    id: userId,
    user_metadata: {
      tenant_id: null, // No tenant yet
    },
  };

  return {
    auth: {
      getUser: vi.fn().mockResolvedValue({
        data: { user: userWithoutTenant },
        error: null,
      }),
      getSession: vi.fn().mockResolvedValue({
        data: {
          session: {
            ...MOCK_SESSION,
            user: userWithoutTenant,
          },
        },
        error: null,
      }),
    },
    from: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    insert: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({
      data: null,
      error: null,
    }),
  } as unknown as SupabaseClient<Database>;
}

/**
 * Pattern 5: Mock specific database queries
 *
 * Use this to mock database responses for specific tables
 */
export function mockDatabaseQuery(
  client: SupabaseClient<Database>,
  tableName: string,
  data: unknown | null,
  error: unknown | null = null
): void {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  vi.spyOn(client, 'from').mockImplementation((table): any => {
    if (table === tableName) {
      return {
        select: vi.fn().mockReturnThis(),
        insert: vi.fn().mockReturnThis(),
        update: vi.fn().mockReturnThis(),
        delete: vi.fn().mockReturnThis(),
        eq: vi.fn().mockReturnThis(),
        single: vi.fn().mockResolvedValue({ data, error }),
        maybeSingle: vi.fn().mockResolvedValue({ data, error }),
      };
    }
    return client.from(table);
  });
}

/**
 * Pattern 6: Mock RLS policy enforcement
 *
 * Use this to test that RLS policies are working correctly
 */
export function mockRLSPolicyBlock(
  client: SupabaseClient<Database>
): void {
  // Mock database to return empty results (RLS policy blocks access)
  // Type assertion needed for complex Vitest mocking - acceptable in test templates
  const mockResponse = {
    select: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({
      data: null,
      error: { message: 'No rows found', code: 'PGRST116' },
    }),
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  vi.spyOn(client, 'from').mockReturnValue(mockResponse as any);
}

/**
 * Pattern 7: Separate client for password verification
 *
 * CRITICAL PATTERN: When testing password changes or verification,
 * NEVER use signInWithPassword() on the same client as the authenticated session!
 *
 * Problem: signInWithPassword() creates a NEW session that overwrites the current
 * session cookies, causing updateUser() to fail silently.
 *
 * Solution: Create a separate Supabase client with persistSession: false for
 * password verification only.
 *
 * Use this for testing:
 * - Password change flows
 * - Password verification before sensitive operations
 * - Re-authentication flows
 *
 * Real implementation example (from apps/web/app/actions/index.ts:206-213):
 * ```typescript
 * const verifyClient = createSupabaseClient(supabaseUrl, supabaseAnonKey, {
 *   auth: {
 *     persistSession: false,    // Don't persist verification session
 *     autoRefreshToken: false,
 *     detectSessionInUrl: false,
 *   },
 * });
 * ```
 */
export function createPasswordVerificationClient(
  email: string,
  password: string,
  shouldSucceed: boolean = true
): SupabaseClient<Database> {
  const verifyUser: User = shouldSucceed
    ? { ...MOCK_USER, email }
    : null;

  return {
    auth: {
      signInWithPassword: vi.fn().mockResolvedValue({
        data: { user: verifyUser, session: verifyUser ? MOCK_SESSION : null },
        error: shouldSucceed ? null : { message: 'Invalid login credentials', status: 401 },
      }),
      // These should NOT be called on verification client
      getUser: vi.fn().mockImplementation(() => {
        throw new Error('Do not call getUser() on verification client - use main session client');
      }),
      updateUser: vi.fn().mockImplementation(() => {
        throw new Error('Do not call updateUser() on verification client - use main session client');
      }),
    },
  } as unknown as SupabaseClient<Database>;
}

/**
 * Helper: Create request headers with auth token
 */
export function createAuthHeaders(
  tenantId: string = MOCK_IDS.TENANT_ID,
  additionalHeaders: Record<string, string> = {}
): Record<string, string> {
  return {
    'Authorization': 'Bearer mock-jwt-token',
    'Content-Type': 'application/json',
    'X-Tenant-ID': tenantId,
    ...additionalHeaders,
  };
}

/**
 * USAGE EXAMPLES:
 *
 * Example 1: Basic authenticated test
 * ```typescript
 * import { createMockSupabaseClient, MOCK_IDS } from '@/__tests__/helpers/auth-mock';
 *
 * describe('My API Route', () => {
 *   it('returns data for authenticated user', async () => {
 *     const mockSupabase = createMockSupabaseClient();
 *     // Use mockSupabase in test...
 *   });
 * });
 * ```
 *
 * Example 2: Test tenant isolation
 * ```typescript
 * it('prevents access to other tenant data', async () => {
 *   const mockSupabase = createMockSupabaseClient(
 *     MOCK_IDS.USER_ID,
 *     MOCK_IDS.TENANT_ID
 *   );
 *   mockRLSPolicyBlock(mockSupabase);
 *
 *   const request = new NextRequest(url, {
 *     headers: createAuthHeaders(MOCK_IDS.SECOND_TENANT_ID)
 *   });
 *
 *   const response = await GET(request);
 *   expect(response.status).toBe(404); // RLS blocks access
 * });
 * ```
 *
 * Example 3: Test unauthenticated access
 * ```typescript
 * it('returns 401 when not authenticated', async () => {
 *   const mockSupabase = createUnauthenticatedSupabaseClient();
 *
 *   const request = new NextRequest(url, {
 *     headers: { 'Content-Type': 'application/json' }
 *     // No Authorization header
 *   });
 *
 *   const response = await GET(request);
 *   expect(response.status).toBe(401);
 * });
 * ```
 *
 * Example 4: Mock specific database response
 * ```typescript
 * it('returns asset metadata', async () => {
 *   const mockSupabase = createMockSupabaseClient();
 *   const mockAsset = {
 *     id: 'ast_123',
 *     tenant_id: MOCK_IDS.TENANT_ID,
 *     filename: 'test.jpg',
 *   };
 *
 *   mockDatabaseQuery(mockSupabase, 'dv.sat_asset_metadata', mockAsset);
 *
 *   const response = await GET(request);
 *   const data = await response.json();
 *   expect(data).toEqual(mockAsset);
 * });
 * ```
 *
 * Example 5: Test password change with separate verification client (CRITICAL PATTERN)
 * ```typescript
 * it('successfully changes password with correct current password', async () => {
 *   // Main session client - for getUser() and updateUser()
 *   const mockSupabase = createMockSupabaseClient();
 *
 *   // Separate verification client - ONLY for password verification
 *   const mockVerifyClient = createPasswordVerificationClient(
 *     'test@example.com',
 *     'currentPassword',
 *     true  // verification succeeds
 *   );
 *
 *   // Mock the createClient import to return separate clients
 *   vi.mock('@supabase/supabase-js', () => ({
 *     createClient: vi.fn(() => mockVerifyClient),
 *   }));
 *
 *   // Test password change action
 *   mockSupabase.auth.updateUser.mockResolvedValue({
 *     data: { user: MOCK_USER },
 *     error: null,
 *   });
 *
 *   const formData = new FormData();
 *   formData.set('currentPassword', 'currentPassword');
 *   formData.set('newPassword', 'newPassword123');
 *   formData.set('confirmNewPassword', 'newPassword123');
 *
 *   await changePasswordAction(formData);
 *
 *   // Verify verification client was used for password check
 *   expect(mockVerifyClient.auth.signInWithPassword).toHaveBeenCalledWith({
 *     email: 'test@example.com',
 *     password: 'currentPassword',
 *   });
 *
 *   // Verify main client was used for password update
 *   expect(mockSupabase.auth.updateUser).toHaveBeenCalledWith({
 *     password: 'newPassword123',
 *   });
 * });
 *
 * it('rejects password change with incorrect current password', async () => {
 *   const mockSupabase = createMockSupabaseClient();
 *
 *   // Verification fails - wrong password
 *   const mockVerifyClient = createPasswordVerificationClient(
 *     'test@example.com',
 *     'wrongPassword',
 *     false  // verification fails
 *   );
 *
 *   vi.mock('@supabase/supabase-js', () => ({
 *     createClient: vi.fn(() => mockVerifyClient),
 *   }));
 *
 *   const formData = new FormData();
 *   formData.set('currentPassword', 'wrongPassword');
 *   formData.set('newPassword', 'newPassword123');
 *   formData.set('confirmNewPassword', 'newPassword123');
 *
 *   await changePasswordAction(formData);
 *
 *   // Verify updateUser was NEVER called since verification failed
 *   expect(mockSupabase.auth.updateUser).not.toHaveBeenCalled();
 * });
 * ```
 */
