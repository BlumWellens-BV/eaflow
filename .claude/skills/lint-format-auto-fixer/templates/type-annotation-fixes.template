# Type Annotation Fix Templates

Use these templates to replace `any` types with proper TypeScript types.

## Template 1: Known Structure

When you know the expected shape:

```typescript
// ❌ BEFORE - any type
function handler(data: any) {
  return data.field;
}

// ✅ AFTER - Interface
interface DataType {
  field: string;
  optional?: number;
}

function handler(data: DataType) {
  return data.field;
}
```

## Template 2: Unknown Structure

When structure is uncertain, use `unknown` with type guards:

```typescript
// ❌ BEFORE - any type
function process(data: any) {
  return data.value;
}

// ✅ AFTER - unknown with type guard
function process(data: unknown) {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return (data as { value: unknown }).value;
  }
  return undefined;
}
```

## Template 3: Partial Structure

When you know some fields but not all:

```typescript
// ❌ BEFORE - any type
function detectPackage(pkg: any) {
  return pkg?.name || pkg?.version;
}

// ✅ AFTER - Partial interface
interface PartialPackage {
  name?: string;
  version?: string;
  [key: string]: unknown; // Allow other fields
}

function detectPackage(pkg: PartialPackage) {
  return pkg?.name || pkg?.version;
}
```

## Template 4: Generic Function

For functions that work with any type:

```typescript
// ❌ BEFORE - any type
function identity(value: any) {
  return value;
}

// ✅ AFTER - Generic type
function identity<T>(value: T): T {
  return value;
}
```

## Template 5: JSON Parse

For parsing JSON with unknown structure:

```typescript
// ❌ BEFORE - any type
const data: any = JSON.parse(jsonString);

// ✅ AFTER - unknown with validation
const data: unknown = JSON.parse(jsonString);

// Validate structure
if (isValidData(data)) {
  // Now safe to use
  processData(data);
}

function isValidData(data: unknown): data is DataType {
  return (
    typeof data === 'object' &&
    data !== null &&
    'requiredField' in data
  );
}
```

## Template 6: External Library

For third-party library without types:

```typescript
// ❌ BEFORE - any type
const result: any = externalLibrary.doSomething();

// ✅ AFTER - Define types
interface LibraryResult {
  success: boolean;
  data?: unknown;
  error?: string;
}

const result = externalLibrary.doSomething() as LibraryResult;
```

## Template 7: Event Handlers

For event handlers with any event type:

```typescript
// ❌ BEFORE - any type
function handleEvent(event: any) {
  console.log(event.target.value);
}

// ✅ AFTER - Proper event type
function handleEvent(event: React.ChangeEvent<HTMLInputElement>) {
  console.log(event.target.value);
}

// Or for unknown events
function handleEvent(event: Event) {
  if (event.target instanceof HTMLInputElement) {
    console.log(event.target.value);
  }
}
```

## Template 8: Function Parameters

For callback parameters:

```typescript
// ❌ BEFORE - any type
function map(arr: any[], callback: (item: any) => any) {
  return arr.map(callback);
}

// ✅ AFTER - Generic types
function map<T, R>(arr: T[], callback: (item: T) => R): R[] {
  return arr.map(callback);
}
```

## Type Guard Helpers

Common type guard patterns:

```typescript
// Check if object
function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null;
}

// Check if has field
function hasField<K extends string>(
  obj: unknown,
  field: K
): obj is Record<K, unknown> {
  return isObject(obj) && field in obj;
}

// Check if string
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

// Check if number
function isNumber(value: unknown): value is number {
  return typeof value === 'number';
}

// Check if array
function isArray(value: unknown): value is unknown[] {
  return Array.isArray(value);
}
```

## Usage Examples

### Example 1: Logger Package Detection

```typescript
// ❌ BEFORE - any type (commit f0fa8ae4)
function detectPackage(pkg: any) {
  return pkg?.name;
}

// ✅ AFTER - Proper type
interface Package {
  name?: string;
  version?: string;
}

function detectPackage(pkg: Package | unknown) {
  if (typeof pkg === 'object' && pkg !== null && 'name' in pkg) {
    return (pkg as Package).name;
  }
  return undefined;
}
```

### Example 2: API Response

```typescript
// ❌ BEFORE - any type
async function fetchData(url: string): Promise<any> {
  const response = await fetch(url);
  return response.json();
}

// ✅ AFTER - Generic with validation
interface ApiResponse<T> {
  data: T;
  error?: string;
}

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  const response = await fetch(url);
  const data: unknown = await response.json();

  // Validate structure
  if (isValidResponse<T>(data)) {
    return data;
  }

  throw new Error('Invalid response structure');
}

function isValidResponse<T>(data: unknown): data is ApiResponse<T> {
  return (
    typeof data === 'object' &&
    data !== null &&
    'data' in data
  );
}
```

### Example 3: Configuration Object

```typescript
// ❌ BEFORE - any type
function loadConfig(config: any) {
  return {
    apiUrl: config.apiUrl || 'default',
    timeout: config.timeout || 5000
  };
}

// ✅ AFTER - Partial type
interface Config {
  apiUrl: string;
  timeout: number;
  debug?: boolean;
}

function loadConfig(config: Partial<Config>): Config {
  return {
    apiUrl: config.apiUrl ?? 'default',
    timeout: config.timeout ?? 5000,
    debug: config.debug ?? false
  };
}
```

## Decision Tree

```
Is the structure known?
├─ Yes → Use interface/type
│  └─ Is it optional? → Use Partial<T> or optional fields
│
└─ No → Use unknown
   ├─ Need to access fields? → Add type guards
   ├─ Pass-through only? → Keep as unknown
   └─ Generic function? → Use <T> generic
```

## Checklist

- [ ] Identify what type `any` represents
- [ ] Check if structure is known or unknown
- [ ] If known: Create interface or type alias
- [ ] If unknown: Use `unknown` type
- [ ] Add type guards for `unknown` types
- [ ] Consider using generics for flexible functions
- [ ] Document why type chosen (comment)
- [ ] Verify type checking: `pnpm typecheck`
- [ ] Test runtime behavior unchanged

## Notes

- Prefer `unknown` over `any` when type is truly unknown
- Use type guards to safely narrow `unknown` types
- Document assumptions about unknown data
- Consider adding runtime validation for critical paths
- Use `as` casting sparingly and with validation
